References
	Mapping IDL to Python
		http://www.scicoder.org/mapping-idl-to-python/
		: Not always the best reference. For example, for Amoeba minimisation
		: it points to a bespoke python script rather than the Scipy
		: implementation

Initial questions
	Data
		input formats?
			ESRI
			ENVI HDR
			Other raster formats (GeoTIFF etc)
			Custom
				binary?
					watch for endianess
		output formats?
		What data structures are used?
			What is the best way to translate them to numpy?
		Does the code need to explicitly deal with spatial aspects of the data (projections etc)?
			or does it just see an array of pixels
		How can I breakdown the large global data structure to be more modular?
			Identify coherent subsets of data required by the processing modules
	What are the plotting requirements?
		Should the plots be generated by Python at all?
			: Can I just write out to HDF using an appropriate convention(CF-1.2?),
			: and then use standard tools (ESRI, ENVI, Panoply) to visualise the
			: data?
		If plotting from Python, what library will I need?
			Matplotlib, Basemap, veusz...
	Processing:
		numpy, scipy
		does single or double precision matter?
	What IDL-specific capabilities are used that might be hard to substitute in Python?

sambuca_2009.pro
	function machine_name
		:Straightforward. On windows it searches the environment and returns 
		:the machine name. On linux it returns "unix" but it could easily
		:check the value of $HOSTNAME.
	function DO_whole_guacamole
		:God function that appears to be the entry point to everything
		Arguments
			pstate?
			zzzz?
		Where is the common SAMBUCA_share structure defined?
		whole_guacamole is a structure of arrays
			What is the purpose of each array?
				name
				value
				pupper
					:an upper limit to something
				plower
					:a lower limit to something
				start
				scale
					:defines the initial step size used by the amoeba
					:minimisation routine.
			Number of parameters is hard-coded. 
				Could be data driven?
			Ask the team for explanation of each element set
				what is 'CHL', 'CDOM' etc

amoeba_clw7.pro
	Is the 7 a version number?
		If so, what is the history?
	Performs multidimensional minimisation of a function using the downhill simplex method
		Does not require a derivative function
	Appears to be a modified version of the IDL standard function.
		: I suspect that one modification is the splitting out of the
		: amotry_CLW2 function, and the addition of the common block, as the
		: original function block comment indicates no common blocks. Would
		: need to diff against original to check, but it probably doesn't
		: matter for the port.
		ToDo: identify whether a replacement exists in SciPy.
			Yes
				: downhill simplex (Nelder-Mead/Amoeba) is available as an option
				: in minimise using method='Nelder-Mead'
				: http://stackoverflow.com/questions/9613381/python-function-minimisation-without-derivative
				: http://docs.scipy.org/doc/scipy/reference/tutorial/optimize.html?highlight=nelder
			Does the IDL function do anything strange that will prevent use of the SciPy version?

IDL quirks to watch
	arrays
		IDL arrays are row-major, but differ from standard matrix notation by using (column, row) rather than (row, column)
		: so indexing looks like column-major but it's not. Rationale is that
		: memory layout for 2D images matches the data access ordering of device
		: scanlines
			will just have to watch indexing orders in Python
		array subscripts are 0-based (yeay)
		implicit array operations
		default is to use [] for array subscripts, but () is legal (and confusing since it looks like a function call)
	Common Blocks
		Global data dressed up so it doesn't look like a bad idea, but it is.
		it could be addressed by objects: common blocks become object data, functions and procedures become methods
	Functions & Procedures
		It looks like procedures don't have a return value, but functions do.
		Side effects!! Both functions and procedures routinely make permanent changes to input arguments
		Keyword arguments
			names can be shortened, so watch for errors caused by similar names
	dynamic typing
		values have a hard type (string, float, double etc)
		references can point to any type
		: So a='a' followed by a=3 does not change a string to an int. It just
		: changes the data type referenced by a
	data types
		default int is only 16 bits. Need long for 32 bits
		float (32 bits) and double (64 bits) make sense
